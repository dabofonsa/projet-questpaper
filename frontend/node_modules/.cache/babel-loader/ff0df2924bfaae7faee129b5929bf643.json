{"ast":null,"code":"import raf from 'raf';\nvar MODE;\n\n(function (MODE) {\n  MODE[MODE[\"MODE_TIMEOUT\"] = 0] = \"MODE_TIMEOUT\";\n  MODE[MODE[\"MODE_INTERVAL\"] = 1] = \"MODE_INTERVAL\";\n})(MODE || (MODE = {}));\n\nconst fnMap = new Map();\nconst executionSet = new Set();\nlet rafStarted = false;\nlet startId = 0;\n\nfunction getTimeStamp() {\n  return new Date().getTime();\n}\n\nfunction executeFn(value) {\n  const {\n    fn,\n    args\n  } = value;\n  fn(...args);\n}\n\nfunction runFunction() {\n  if (executionSet.size === 0) return;\n  executionSet.forEach(executeFn);\n  executionSet.clear();\n}\n\nconst checkTick = currentTimeTick => (value, id) => {\n  const {\n    nextTick,\n    ms,\n    mode\n  } = value;\n\n  if (currentTimeTick - nextTick >= 0) {\n    executionSet.add(value);\n\n    if (mode === MODE.MODE_TIMEOUT) {\n      fnMap.delete(id);\n    } else {\n      fnMap.set(id, { ...value,\n        nextTick: nextTick + ms\n      });\n    }\n  }\n};\n\nfunction loop() {\n  if (fnMap.size === 0) {\n    rafStarted = false;\n    return;\n  }\n\n  const currentTimeTick = getTimeStamp();\n  fnMap.forEach(checkTick(currentTimeTick));\n  runFunction();\n\n  if (fnMap.size === 0) {\n    rafStarted = false;\n    return;\n  }\n\n  raf(loop);\n}\n\nfunction addId(_ref) {\n  let {\n    fn,\n    ms,\n    args,\n    mode\n  } = _ref;\n  if (!fn) return null;\n  const currentId = startId;\n  fnMap.set(currentId, {\n    fn,\n    ms,\n    nextTick: getTimeStamp() + ms,\n    args,\n    mode\n  });\n\n  if (!rafStarted) {\n    rafStarted = true;\n    raf(loop);\n  }\n\n  startId += 1;\n  return currentId;\n}\n\nfunction removeId(id) {\n  if (id == null) return;\n\n  if (fnMap.has(id)) {\n    fnMap.delete(id);\n  }\n}\n\nexport const setTimeout = function (fn) {\n  let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return addId({\n    fn,\n    ms,\n    args,\n    mode: MODE.MODE_TIMEOUT\n  });\n};\nexport const clearTimeout = removeId;\nexport const setInterval = function (fn) {\n  let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  return addId({\n    fn,\n    ms,\n    args,\n    mode: MODE.MODE_INTERVAL\n  });\n};\nexport const clearInterval = removeId;\nexport default {\n  setTimeout,\n  clearTimeout,\n  setInterval,\n  clearInterval\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import raf from 'raf';\r\nvar MODE;\r\n(function (MODE) {\r\n    MODE[MODE[\"MODE_TIMEOUT\"] = 0] = \"MODE_TIMEOUT\";\r\n    MODE[MODE[\"MODE_INTERVAL\"] = 1] = \"MODE_INTERVAL\";\r\n})(MODE || (MODE = {}));\r\nconst fnMap = new Map();\r\nconst executionSet = new Set();\r\nlet rafStarted = false;\r\nlet startId = 0;\r\nfunction getTimeStamp() {\r\n    return new Date().getTime();\r\n}\r\nfunction executeFn(value) {\r\n    const { fn, args } = value;\r\n    fn(...args);\r\n}\r\nfunction runFunction() {\r\n    if (executionSet.size === 0)\r\n        return;\r\n    executionSet.forEach(executeFn);\r\n    executionSet.clear();\r\n}\r\nconst checkTick = (currentTimeTick) => (value, id) => {\r\n    const { nextTick, ms, mode } = value;\r\n    if (currentTimeTick - nextTick >= 0) {\r\n        executionSet.add(value);\r\n        if (mode === MODE.MODE_TIMEOUT) {\r\n            fnMap.delete(id);\r\n        }\r\n        else {\r\n            fnMap.set(id, {\r\n                ...value,\r\n                nextTick: nextTick + ms,\r\n            });\r\n        }\r\n    }\r\n};\r\nfunction loop() {\r\n    if (fnMap.size === 0) {\r\n        rafStarted = false;\r\n        return;\r\n    }\r\n    const currentTimeTick = getTimeStamp();\r\n    fnMap.forEach(checkTick(currentTimeTick));\r\n    runFunction();\r\n    if (fnMap.size === 0) {\r\n        rafStarted = false;\r\n        return;\r\n    }\r\n    raf(loop);\r\n}\r\nfunction addId({ fn, ms, args, mode }) {\r\n    if (!fn)\r\n        return null;\r\n    const currentId = startId;\r\n    fnMap.set(currentId, {\r\n        fn,\r\n        ms,\r\n        nextTick: getTimeStamp() + ms,\r\n        args,\r\n        mode,\r\n    });\r\n    if (!rafStarted) {\r\n        rafStarted = true;\r\n        raf(loop);\r\n    }\r\n    startId += 1;\r\n    return currentId;\r\n}\r\nfunction removeId(id) {\r\n    if (id == null)\r\n        return;\r\n    if (fnMap.has(id)) {\r\n        fnMap.delete(id);\r\n    }\r\n}\r\nexport const setTimeout = (fn, ms = 0, ...args) => addId({ fn, ms, args, mode: MODE.MODE_TIMEOUT });\r\nexport const clearTimeout = removeId;\r\nexport const setInterval = (fn, ms = 0, ...args) => addId({ fn, ms, args, mode: MODE.MODE_INTERVAL });\r\nexport const clearInterval = removeId;\r\nexport default { setTimeout, clearTimeout, setInterval, clearInterval };\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}